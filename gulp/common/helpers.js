/**
 * Additional function for builder
 * @author Kolbeshin F.A.
 */
'use strict';

const { path, cwd } = require('../../lib/platform/path');
const fs = require('fs-extra');
const pMap = require('p-map');
const { joinContents } = require('../../lib/helpers');
const logger = require('../../lib/logger').logger();
const getLogLevel = require('../../lib/get-log-level');
const workerPool = require('workerpool');
const { MAX_PATH, CPUS_COUNT, TOTAL_MEMORY } = require('../../lib/builder-constants');
const withLockfile = require('../../lib/with-lockfile');

/**
 * check source file necessity in output directory by
 * given gulp configuration
 * @param config - current gulp configuration
 * @param file - current file
 * @returns {boolean}
 */
function checkSourceNecessityByConfig(config, extension) {
   if (!config.typescript && extension === '.ts') {
      return false;
   }

   if (!config.less && extension === '.less') {
      return false;
   }

   if (!config.wml && ['.wml', '.tmpl'].includes(extension)) {
      return false;
   }

   if (!config.deprecatedXhtml && extension === '.xhtml') {
      return false;
   }
   return true;
}

/**
 * Функция, которая нужна в сборке для выбора между gulp.dest и gulp.symlink
 * @param {BuildConfiguration} config конфигурация сборки
 * @param {ModuleInfo} moduleInfo информация о модуле
 * @returns {Function} возвращаем функцию для gulp-if
 */
function needSymlink(taskParameters, config, moduleInfo, isFirstBuild) {
   const hasLocalization = config.localizations.length > 0;
   const checkForSymlink = (file) => {
      taskParameters.addFileToCopy(moduleInfo.outputName, file.pRelative);

      // replace AMD content with UMD content just before writing it to the disk
      // UMD content should be used only in debug mode for tests, but in release mode
      // all compiled code should be in AMD format for now
      if (file.umdContent && moduleInfo.hasUMDModule(file.pRelative)) {
         file.contents = Buffer.from(file.umdContent);
      }

      /**
       * After first build every next build should
       * check firstly if there is a corresponding file
       * in output directory. If it's a symlink, overwriting
       * it will overwrite origin file and save this symlink, so that
       * could cause some unwanted consequences. Thus, we should
       * remove output file before writing/(creating a symlink) for a
       * new one
       */
      if (config.compiled && !isFirstBuild) {
         const outputPath = path.join(moduleInfo.output, file.pRelative);
         if (fs.pathExistsSync(outputPath)) {
            fs.unlinkSync(outputPath);
         }
      }

      if (file.useSymlink && !file.strictCopy) {
         // if it's a file from compiled sources to be symlink to, rebase it to
         // compiled sources directory, otherwise symlink it "as is"
         if (file.origin) {
            file.pHistory = [file.origin];
            file.base = file.compiledBase;
         }
         return true;
      }

      /**
       * symlinks can't be created for compiled modules, because it's symlinked
       * and gulp.symlink in that case would cause symbolic links loop and ELOOP error.
       */
      if (moduleInfo.compiled && typeof moduleInfo.compiled === 'boolean') {
         return false;
      }

      // don't use symlinks if it's release mode or symlinks is disabled manually or symlinks disabled
      // for certain files
      if ((config.isReleaseMode && !config.localStand) || !config.symlinks || file.strictCopy) {
         // Allow creating symlinks on TypeScript files (support source map on original sources).
         const shouldLinkTSSource = (
            file.pExtname.startsWith('.ts') &&
            (
               taskParameters.config.sourceMaps ||
               taskParameters.config.inlineSourceMaps
            )
         );

         if (!shouldLinkTSSource) {
            return false;
         }
      }

      if (file.pExtname === '.html' && (hasLocalization || config.debugCustomPack || config.isReleaseMode)) {
         return false;
      }

      // symlinks can't be used if we have to save compiled template into source for custom packer needs.
      if ((config.debugCustomPack) && ['.tmpl', '.xhtml', '.wml'].includes(file.pExtname)) {
         return false;
      }

      // symlinks can't be used for files generated by ourselves during current build.
      const relativePath = path.relative(moduleInfo.path, file.pHistory[0]);
      if (relativePath.includes('..') || path.isAbsolute(relativePath)) {
         return false;
      }

      // also symlinks can't be used if there was path transliteration. Symlinks doesn't work in this case.
      // It's Gulp own error
      return file.pHistory.length === 1;
   };
   return (file) => {
      const isSymlink = checkForSymlink(file);
      if (isSymlink && file.pPath.length >= MAX_PATH) {
         const message = `Current path exceeded a maximum system path length(${file.pPath.length} symbols). Should be less than ${MAX_PATH} symbols.`;
         logger.error({
            message,
            filePath: file.pPath,
            moduleInfo
         });
      }
      return isSymlink;
   };
}

/**
 * Генерация задачи загрузки кеша сборки
 * @param {TaskParameters} taskParameters параметры для задач
 * @returns {function(): *}
 */
function generateTaskForLoadCache(taskParameters) {
   return async function loadCache() {
      const startTime = Date.now();
      const { changedFilesWithDependencies } = taskParameters.config;

      const lockFilePath = withLockfile.toFileName(taskParameters, 'common-cache');

      await withLockfile(lockFilePath, async() => {
         if (taskParameters.config.compiled) {
            await taskParameters.cache.loadCompiled();
         }

         await taskParameters.cache.load(changedFilesWithDependencies);
      });

      taskParameters.metrics.storeTaskTime('loadCache', startTime);
   };
}

/**
 * Генерация задачи инициализации пула воркеров
 * @param {TaskParameters} taskParameters параметры для задач
 * @returns {function(): *}
 */
function generateTaskForInitWorkerPool(taskParameters, rootForPlatform) {
   return async function initWorkerPool() {
      const startTime = Date.now();
      let applicationRoot = process.env['application-root'];

      if (!applicationRoot) {
         applicationRoot = rootForPlatform;
      }

      let maxWorkers = taskParameters.config.rawConfig['max-workers-for-builder'];

      /**
       * throw an error, if custom worker count more than
       * system max threads - 1 (1 thread for Node.Js main process)
       */
      if (maxWorkers && maxWorkers > (CPUS_COUNT.length - 1)) {
         throw new Error(`Custom max worker's count must be less than ${CPUS_COUNT} for current executing machine!`);
      }
      if (!maxWorkers) {
         maxWorkers = CPUS_COUNT - 1;
      }

      const requiredModules = taskParameters.config.modules
         .filter(currentModule => currentModule.required)
         .map(currentModule => currentModule.name);

      process.env.logs = getLogLevel(process.argv);
      process.env.logsPath = taskParameters.config.logs;
      process.env.cloud = taskParameters.config.cloud;
      process.env.responsibleOfCloud = taskParameters.config.responsibleOfCloud;
      process.env['application-root'] = applicationRoot;
      process.env['resources-path'] = taskParameters.config.resourcesUrl ? '/resources/' : '/';
      process.env['main-process-cwd'] = cwd();
      process.env['required-modules'] = JSON.stringify(requiredModules);

      // передавать --max-old-space-size через workerThreadOpts не нужно. Начиная с Node.Js версии 11.7.0,
      // workerpool автоматически использует 'thread' в качестве типа воркера. worker_thread хоть и принимает
      // опции в execArgv, но нужная нам опция --max-old-space-size игнорируется и наследуется
      // исключительно от родителя, если в родительском процессе она присутствует. Поэтому определяем
      // эту опцию в родителе. Эта опция нам нужна для тяжёлых проектов, которые требуют больше
      // памяти для обработки внутри воркера.
      process.execArgv.push(`--max-old-space-size=${TOTAL_MEMORY}`);
      const workerPoolConfig = {
         maxWorkers: maxWorkers || 1,
         env: {
            logs: process.env.logs,
            logsPath: process.env.logsPath,
            cloud: process.env.cloud,
            responsibleOfCloud: process.env.responsibleOfCloud,
            'application-root': process.env['application-root'],
            'resources-path': process.env['resources-path'],
            'main-process-cwd': process.env['main-process-cwd'],
            'required-modules': requiredModules,
         }
      };

      // save worker's config in cache to use it as debug info
      await fs.outputJson(
         path.join(taskParameters.config.cachePath, 'workerpool-config.json'),
         { systemMaxWorkers: CPUS_COUNT, ...workerPoolConfig, TOTAL_MEMORY }
      );

      // Нельзя занимать больше ядер чем есть. Основной процесс тоже потребляет ресурсы
      taskParameters.setWorkerPool(
         workerPool.pool(path.join(__dirname, '../common/worker.js'), workerPoolConfig)
      );
      taskParameters.metrics.storeTaskTime('initWorkerPool', startTime);
   };
}

/**
 * Генерация задачи убийства пула воркеров
 * @param {TaskParameters} taskParameters параметры для задач
 * @returns {function(): *}
 */
function generateTaskForTerminatePool(taskParameters) {
   return function terminatePool() {
      if (!process.env['builder-tests']) {
         delete process.env['application-root'];
      }
      return taskParameters.pool.terminate();
   };
}

/**
 * Оборачивает функцию в воркере, чтобы была возможность вернуть ошибки и варнинги от WS.
 * Работает в тандеме с gulp/helpers/exec-in-pool.js
 * @param {Function} func функция, которую оборачиваем
 * @returns {Function}
 */
function wrapWorkerFunction(func) {
   return async(funcArgs, filePath = null, moduleInfo = null) => {
      logger.setInfo(filePath, moduleInfo);
      let result;
      try {
         result = func(...funcArgs);
         if (result instanceof Promise) {
            result = await result;
         }
      } catch (error) {
         const resultError = { ...error };
         resultError.message = error.message;
         resultError.stack = error.stack;
         return [resultError, null, logger.getMessageForReport()];
      }
      return [null, result, logger.getMessageForReport()];
   };
}


async function saveExtraMetaIntoLogs(taskParameters) {
   const result = {};
   const { logs } = taskParameters.config;
   Object.keys(taskParameters.filesToCopy).forEach((currentModule) => {
      result[currentModule] = [...taskParameters.filesToCopy[currentModule]];
   });

   // save logs with current build timestamp
   let currentBuildLogsPath;
   if (taskParameters.config.builderTests) {
      currentBuildLogsPath = logs;
   } else {
      currentBuildLogsPath = path.join(logs, new Date().getTime().toString());
   }
   await fs.outputJson(`${currentBuildLogsPath}/changed-files.json`, result);
   await fs.outputJson(`${currentBuildLogsPath}/garbage.json`, taskParameters.config.getGarbageList());
   await fs.outputJson(`${currentBuildLogsPath}/files-with-errors.json`, [...taskParameters.cache.getFilesWithErrors()]);
}

function generateTaskForGetJoinedMeta(taskParameters) {
   const modulesToProcess = taskParameters.config.modules
      .filter(moduleInfo => moduleInfo.compiled && typeof moduleInfo.compiled === 'boolean');

   return async function getCompiledJoinedMeta() {
      const startTime = Date.now();

      await pMap(
         modulesToProcess,
         async(moduleInfo) => {
            if (taskParameters.config.needModuleDependencies) {
               const currentDeps = await fs.readJson(path.join(moduleInfo.output, 'module-dependencies.json'));
               taskParameters.cache.storeLocalModuleDependencies(currentDeps);
            }

            const contentsPath = path.join(moduleInfo.output, 'contents.json');
            if (
               taskParameters.config.contents &&
               taskParameters.config.commonContents
            ) {
               const currentContents = await fs.readJson(contentsPath);
               joinContents(taskParameters.config.commonContents, currentContents);
            }
         }
      );

      taskParameters.metrics.storeTaskTime('generate joined meta', startTime);
   };
}

function generateTaskForSaveCache(taskParameters, migrateCache) {
   return async function saveCache() {
      const startTime = Date.now();

      const lockFilePath = withLockfile.toFileName(taskParameters, 'common-cache');

      await withLockfile(lockFilePath, async() => {
         await taskParameters.cache.save(migrateCache);
         await saveExtraMetaIntoLogs(taskParameters);
      });

      taskParameters.metrics.storeTaskTime('save cache', startTime);
   };
}

module.exports = {
   needSymlink,
   generateTaskForLoadCache,
   generateTaskForSaveCache,
   generateTaskForInitWorkerPool,
   generateTaskForTerminatePool,
   generateTaskForGetJoinedMeta,
   wrapWorkerFunction,
   checkSourceNecessityByConfig
};
